// This data ingestion pipeline works with the output from the DataGenerator project.
//
// The reason for separating data generation from ingestion is:
//
//  - For realism. In real-world scenarios, you will be taking data from external sources,
//    such as existing business data or documents provided by product manufacturers, and need
//    to ingest that data into your system. You must only ingest the data you will really have
//    (e.g., final PDFs) and not artificially-available data such as the intermediate JSON
//    files generated by the DataGenerator.
//
//  - For evaluation of different strategies. There are many possible ways to represent the
//    ingested data (for example, how to chunk and embed text), and we want to be able to
//    try out different ingestion strategies and then numerally evaluate the quality of the
//    end-to-end system.
//
// In this case the data ingestor does *not* write directly to DBs, but instead emits .json
// files that the Backend project can quickly import. This is because data ingestion can be
// a lengthy process, requiring dependencies, and we want each person trying out this sample
// to be able to run the app without going through the ingestion process first.
// In real-world cases that's likely useful too, since you can't normally write directly to
// production DBs.

// TODO: Once the data generator is moved into this solution, we can use a relative path to its output
using System.Text.Json;
using eShopSupport.Backend.Data;

var generatedDataPath = args.Length > 0 ? args[0] : null;
if (string.IsNullOrEmpty(generatedDataPath) || !Directory.Exists(generatedDataPath))
{
    Console.WriteLine("Usage: DataIngestor [path_to_generated_data]");
    return;
}

await IngestGeneratedData(generatedDataPath);

async Task IngestGeneratedData(string path)
{
    var tickets = new List<Ticket>();
    var ticketsSourceDir = Path.Combine(path, "tickets", "threads");
    var inputOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);
    var messageId = 0;
    foreach (var filename in Directory.GetFiles(ticketsSourceDir, "*.json"))
    {
        // TODO: Consider simplifying by ensuring the generated data is already in exactly the right form
        var generated = (await JsonSerializer.DeserializeAsync<GeneratedTicket>(File.OpenRead(filename), inputOptions))!;
        tickets.Add(new Ticket
        {
            TicketId = generated.TicketId,
            ProductId = generated.ProductId,
            CustomerFullName = generated.CustomerFullName,
            ShortSummary = generated.ShortSummary,
            LongSummary = generated.LongSummary,
            CustomerSatisfaction = generated.CustomerSatisfaction,
            Messages = generated.Messages.Select(generatedMessage => new Message
            {
                MessageId = ++messageId,
                AuthorName = generatedMessage.AuthorRole == 0 ? generated.CustomerFullName : "Support",
                Text = generatedMessage.Text
            }).ToList()
        });
    }

    var solutionDir = FindAncestorDirectoryContaining("*.sln");
    var outputDir = Path.Combine(solutionDir, "seeddata", "dev");

    var outputOptions = new JsonSerializerOptions { WriteIndented = true };
    await File.WriteAllTextAsync(Path.Combine(outputDir, "tickets.json"), JsonSerializer.Serialize(tickets, outputOptions));
    Console.WriteLine($"Wrote {tickets.Count} tickets");
}

static string FindAncestorDirectoryContaining(string pattern)
{
    var currentDir = Directory.GetCurrentDirectory();
    while (currentDir != null)
    {
        if (Directory.GetFiles(currentDir, pattern).Any())
        {
            return currentDir!;
        }
        currentDir = Directory.GetParent(currentDir)?.FullName;
    }

    throw new FileNotFoundException($"Could not find a directory containing {pattern}");
}

internal record GeneratedTicket(int TicketId, int ProductId, string CustomerFullName, string ShortSummary, string LongSummary, int? CustomerSatisfaction, List<GeneratedMessage> Messages);
internal record GeneratedMessage(int MessageId, int AuthorRole, string Text);
