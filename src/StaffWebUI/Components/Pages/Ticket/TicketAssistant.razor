@using Microsoft.FluentUI.AspNetCore.Components
@using eShopSupport.ServiceDefaults.Clients.Backend
@inject IJSRuntime JS
@inject BackendClient Backend

<div class="messages-scroller">
    <div class="messages">
        @for (var i = 0; i < messages.Count; i++)
        {
            var id = @$"message{i}";
            var state = messages[i]!;
            <TicketAssistantMessage @key="@id" State="@state" OnCompleted="@HandleResponseCompleted" />
        }
    </div>
</div>

<form class="write-message @(ReplyInProgress ? "in-progress" : "")" @ref="@writeMessageElement" @onsubmit="@SendMessage">
    <FluentButton Class="stop-responding" @onclick="@StopResponding" Appearance="Appearance.Outline">Stop responding</FluentButton>
    <FluentTextArea @bind-Value="@userMessageText" Placeholder="Ask the AI assistant&hellip;" style="width: 100%; height: 100%;" />
</form>

@code {
    CancellationTokenSource? currentReplyCancellationTokenSource;
    List<MessageState> messages = new();
    ElementReference writeMessageElement;
    string? userMessageText;

    [Parameter, EditorRequired]
    public int TicketId { get; set; }

    bool ReplyInProgress => currentReplyCancellationTokenSource?.IsCancellationRequested == false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await using var module = await JS.InvokeAsync<IJSObjectReference>("import", "./Components/Pages/Ticket/TicketAssistant.razor.js");
            await module.InvokeVoidAsync("submitOnEnter", writeMessageElement);
        }
    }

    void SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(userMessageText))
        {
            StopResponding();

            // Add the user's message to the UI
            messages.Add(new MessageState(new() { Text = userMessageText }, null, CancellationToken.None));
            userMessageText = null;

            // Submit request to backend
            currentReplyCancellationTokenSource = new CancellationTokenSource();
            var cancellationToken = currentReplyCancellationTokenSource.Token;
            var request = new AssistantChatRequest(TicketId, messages.Select(m => m.Message).ToList());
            var responseTask = Backend.AssistantChatAsync(request, cancellationToken);

            // Add the assistant's reply to the UI
            var reply = new AssistantChatRequestMessage { IsAssistant = true, Text = string.Empty };
            messages.Add(new MessageState(reply, responseTask, cancellationToken));
        }
    }

    private void HandleResponseCompleted(MessageState state)
    {
        if (messages.LastOrDefault() == state)
        {
            currentReplyCancellationTokenSource = null;
        }

        // If it was cancelled before the response started, remove the message entirely
        // But if there was some text already, keep it
        if (string.IsNullOrEmpty(state.Message.Text))
        {
            messages.Remove(state);
        }
    }

    private void StopResponding()
    {
        currentReplyCancellationTokenSource?.Cancel();
    }

    public record MessageState(AssistantChatRequestMessage Message, Task<Stream>? ResponseTask, CancellationToken CancellationToken);
}
